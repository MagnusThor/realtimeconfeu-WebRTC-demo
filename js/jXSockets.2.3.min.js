/*
* XSockets.NET jXSockets.2.3
* http://xsockets.net/
* Distributed in whole under the terms of the MIT
 
*
* Copyright 2013, Magnus Thor & Ulf Björklund
*
* Permission is hereby granted, free of charge, to any person obtaining
* a copy of this software and associated documentation files (the
* "Software"), to deal in the Software without restriction, including
 
* without limitation the rights to use, copy, modify, merge, publish,
* distribute, sublicense, and/or sell copies of the Software, and to
* permit persons to whom the Software is furnished to do so, subject to
* the following conditions:
 
*
* The above copyright notice and this permission notice shall be
* included in all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 
* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
* MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
* LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
 
* OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
* WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
*/
var Queue = function (b) { var a = this; this.settings = b; this.length = 0; this.items = []; this.timer = 0; a.items.push = function (c) { a.length++; if (a.length === 1) { a.timer = setInterval(function () { var d = a.items.slice(0, 1); if (d.length === 1) { a.items.remove(d[0]); b.dequeued.call(this, d[0]) } }, b.interval) } return Array.prototype.push.call(this, c) }; a.items.remove = function () { var f, d = arguments, c = d.length, e; while (c && this.length) { f = d[--c]; while ((e = this.indexOf(f)) != -1) { this.splice(e, 1) } } a.length--; if (a.length === 0) { b.clean.call(this); clearInterval(a.timer) } return this }; this.enqueue = function (c) { a.items.push({ k: a.length, v: c }) }; this.cleanUp = function () { clearInterval(a.timer); a.items = [] }; this.Empty = function () { a.items.forEach(function (c) { b.dequeued.call(this, c); a.items.remove(c) }, this); clearInterval(a.timer) } }; var Subscriptions = (function () { var c = []; this.add = function (e, h, f) { e = e.toLowerCase(); var d = this.get(e); if (d === null) { var g = new a(e); g.addCallback(h, f); c.push(g); return 1 } d.addCallback(h, f); return d.Callbacks.length }; this.get = function (d) { d = d.toLowerCase(); for (var e = 0; e < c.length; e++) { if (c[e].Name === d) { return c[e] } } return null }; this.getAll = function () { return c }; this.remove = function (e, d) { e = e.toLowerCase(); for (var f = 0; f < c.length; f++) { if (c[f].Name === e) { if (d === undefined) { c.splice(f, 1) } else { c[f].Callbacks.splice(d - 1, 1); if (c[f].Callbacks.length === 0) { c.splice(f, 1) } } return true } } return false }; this.fire = function (f, h, d, e) { f = f.toLowerCase(); for (var g = 0; g < c.length; g++) { if (c[g].Name === f) { if (e === undefined) { c[g].fireCallbacks(h, d) } else { c[g].fireCallback(h, d, e) } } } }; var a = function (d) { this.Name = d; this.Callbacks = []; this.addCallback = function (f, e) { this.Callbacks.push(new b(d, f, e)) }; this.fireCallback = function (g, e, f) { this.Callbacks[f - 1].fn(g); if (typeof (this.Callbacks[f - 1].state) === "object") { if (typeof (this.Callbacks[f - 1].state.options) !== "undefined" && typeof (this.Callbacks[f - 1].state.options.counter) !== "undefined") { this.Callbacks[f - 1].state.options.counter.messages--; if (this.Callbacks[f - 1].state.options.counter.messages === 0) { if (typeof (this.Callbacks[f - 1].state.options.counter.completed) === "function") { this.Callbacks[f - 1].state.options.counter.completed() } } } } if (e && typeof (e) === "function") { e(this.Callbacks[f - 1].name) } }; this.fireCallbacks = function (f, e) { for (var g = 0; g < this.Callbacks.length; g++) { this.fireCallback(f, e, g + 1) } } }; var b = function (d, f, e) { this.name = d; this.fn = f; this.state = e }; return this }); (function () { var a = { Queue: true, Delay: 30, Events: { onError: "xsockets.onerror", open: "xsockets.xnode.open", close: "close", storage: { set: "xsockets.storage.set", get: "xsockets.storage.get", getAll: "xsockets.storage.getall", remove: "xsockets.storage.remove" }, serverstatus: { status: "xsockets.server.status" }, onBlob: "blob", connection: { getallclients: "xsockets.getallclients", onclientconnect: "xsockets.onclientconnect", onclientdisconnect: "xsockets.onclientdisconnect", disconnect: "xsockets.disconnect" } }, Utils: { getParameterByName: function (c) { c = c.replace(/[\[]/, "\\[").replace(/[\]]/, "\\]"); var b = "[\\?&]" + c + "=([^&#]*)"; var e = new RegExp(b); var d = e.exec(window.location.search); if (d == null) { return "" } else { return decodeURIComponent(d[1].replace(/\+/g, " ")) } }, extend: function (e, c) { if (arguments.length > 2) { for (var b = 1; b < arguments.length; b++) { extend(e, arguments[b]) } } else { for (var d in c) { e[d] = c[d] } } return e }, guid: function (d, c) { for (c = d = ""; d++ < 36; c += d * 51 & 52 ? (d ^ 15 ? 8 ^ Math.random() * (d ^ 20 ? 16 : 4) : 4).toString(16) : "-") { } return c } }, WebSocket: function (d, i, g) { var j = null; var o = this; var c = new Subscriptions(); var p = XSockets.Utils.extend({ queue: a.Queue, apikey: null, parameters: {} }, g); this.handler = i; this.channel = {}; if (p.queue) { var e = { dequeued: function (q) { m(q.v.event, q.v.json, q.v.callback) }, clean: function () { }, interval: a.Delay }; this.Queue = new Queue(e) } var l = { subscribe: "xsockets.subscribe", unsubscribe: "xsockets.unsubscribe", getSubscriptions: "xsockets.getsubscriptions", getAllSubscriptions: "xsockets.getallsubscriptions" }; var n = function (r) { var s = "?"; for (var q in r) { s += q + "=" + encodeURIComponent(r[q]) + "&" } s = s.slice(0, s.length - 1); return s }; this.close = function (q) { this.trigger(XSockets.Events.connection.disconnect, {}, q) }; this.getSubscriptions = function () { return c.getAll() }; this.bind = function (s, q, r, u) { var t = { options: r, ready: j.readyState }; if (t.ready === 1) { o.trigger(new XSockets.Message(l.subscribe, { Event: s })) } c.add(s, q, t); if (u && typeof (u) === "function") { u() } }; this.unbind = function (q, r) { if (c.remove(q)) { o.trigger(new XSockets.Message(l.unsubscribe, { Event: q })) } if (r && typeof (r) === "function") { r() } }; this.many = function (s, r, t, q) { o.bind(s, t, XSockets.Utils.extend({ counter: { messages: r, completed: function () { o.unbind(s) } } }, q)) }; this.one = function (r, s, q) { o.bind(r, s, XSockets.Utils.extend({ counter: { messages: 1, completed: function () { o.unbind(r) } } }, q)) }; this.trigger = function (r, q, s) { if (typeof (r) !== "object") { if (arguments.length !== 2 || typeof (q) !== "function") { if (arguments.length === 1) { q = {} } } else { s = q; q = {} } } if (p.queue && typeof (r) !== "object") { o.Queue.enqueue({ event: r, json: q, callback: s }) } else { m(r, q, s) } }; var m = function (s, q, t) { if (typeof (s) !== "object") { s = s.toLowerCase(); var r = XSockets.Message(s, q); h(r.toString()); if (t && typeof (t) === "function") { t() } } else { h(s.toString()); if (q && typeof (q) === "function") { q() } } }; this.send = function (q) { j.send(q) }; var k = function (q, r) { if (c.get(q) === null) { return } if (typeof r === "string") { r = JSON.parse(r) } c.fire(q, r, function (s) { }) }; var f = function (r) { var q = null; if (typeof r.data === "string") { var s = JSON.parse(r.data); q = s.event; k(q, s.data) } else { k(XSockets.Events.onBlob, r.data) } }; var h = function (q) { j.send(q) }; Array.prototype.removeItem = function (r) { for (var q = 0; q < this.length; q++) { if (escape(this[q]).match(escape(r.trim()))) { this.splice(q, 1); break } } return this }; if ("WebSocket" in window) { var b = window.localStorage.getItem("XSocketsClientStorageGuid" + i) !== null ? window.localStorage.getItem("XSocketsClientStorageGuid" + i) : null; if (p.apikey !== null) { p.parameters.apikey = p.apikey } if (b !== null) { p.parameters.XSocketsClientStorageGuid = b } d = d + n(p.parameters); j = new window.WebSocket(d, i) } if (j !== null) { o.bind(a.Events.open, function (r) { window.localStorage.setItem("XSocketsClientStorageGuid" + i, r.StorageGuid); var q = c.getAll(); for (var s = 0; s < q.length; s++) { for (var t = 0; t < q[s].Callbacks.length; t++) { if (q[s].Callbacks[t].ready !== 1) { o.trigger(new XSockets.Message(l.subscribe, { Event: q[s].Name })) } } } }, { subscribe: false }); j.onclose = function (q) { o.Queue.cleanUp(); k("close", q) }; j.onopen = function (q) { k("open", q) }; j.onmessage = function (q) { f(q) } } return { close: o.close, bind: o.bind, unbind: o.unbind, one: o.one, many: o.many, on: o.bind, off: o.unbind, trigger: o.trigger, triggerBinary: o.send, send: o.send, channel: o.channel, subscribe: o.bind, unsubscribe: o.unbind, publish: o.trigger, subscriptions: o.getSubscriptions } }, Channel: function () { var c = function (e, g, f) { var i = a.Utils.guid(); var h = e + "/" + i; var d = new XSockets.WebSocket(h, g, f); d.channel = { Id: i, args: [h, g, f] }; return d }; var b = function (d) { return new XSockets.WebSocket(d.args[0], d.args[1], d.args[2]) }; return { Create: c, Connect: b } }(), Message: function (d, b) { var c = { event: d, data: JSON.stringify(b) }; this.JSON = function () { return c }(); this.toString = function () { return JSON.stringify(c) }; return this } }; if (!window.jXSockets) { window.jXSockets = a } if (!window.XSockets) { window.XSockets = a } })();