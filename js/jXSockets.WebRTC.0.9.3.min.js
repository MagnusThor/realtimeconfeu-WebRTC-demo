var RTCPeerConnection = null; var getUserMedia = null; var attachMediaStream = null; var reattachMediaStream = null; var webrtcDetectedBrowser = null; if (navigator.mozGetUserMedia) { webrtcDetectedBrowser = "firefox"; RTCPeerConnection = mozRTCPeerConnection; RTCSessionDescription = mozRTCSessionDescription; RTCIceCandidate = mozRTCIceCandidate; getUserMedia = navigator.mozGetUserMedia.bind(navigator); attachMediaStream = function (a, b) { a.mozSrcObject = b; a.play() }; reattachMediaStream = function (b, a) { b.mozSrcObject = a.mozSrcObject; b.play() }; MediaStream.prototype.getVideoTracks = function () { return [] }; MediaStream.prototype.getAudioTracks = function () { return [] } } else { if (navigator.webkitGetUserMedia) { webrtcDetectedBrowser = "chrome"; RTCPeerConnection = webkitRTCPeerConnection; getUserMedia = navigator.webkitGetUserMedia.bind(navigator); attachMediaStream = function (a, b) { a.src = webkitURL.createObjectURL(b) }; reattachMediaStream = function (b, a) { b.src = a.src }; if (!webkitMediaStream.prototype.getVideoTracks) { webkitMediaStream.prototype.getVideoTracks = function () { return this.videoTracks }; webkitMediaStream.prototype.getAudioTracks = function () { return this.audioTracks } } if (!webkitRTCPeerConnection.prototype.getLocalStreams) { webkitRTCPeerConnection.prototype.getLocalStreams = function () { return this.localStreams }; webkitRTCPeerConnection.prototype.getRemoteStreams = function () { return this.remoteStreams } } } else { } } XSockets.WebRTC = function (g, d) { var j = this; var f; this.PeerConnections = {}; this.DataChannels = {}; var e = { RTCConfiguration: { iceServers: [{ url: "stun:stun.l.google.com:19302" }] }, MediaConstraints: { mandatory: { OfferToReceiveAudio: true, OfferToReceiveVideo: true }, optional: [{ RtpDataChannels: true }] } }; var k = XSockets.Utils.extend(e, d); var b = (function () { var n = []; this.add = function (p, s, q) { p = p.toLowerCase(); var o = this.get(p); if (o === null) { var r = new l(p); r.addCallback(s, q); n.push(r); return 1 } o.addCallback(s, q); return o.Callbacks.length }; this.get = function (o) { o = o.toLowerCase(); for (var p = 0; p < n.length; p++) { if (n[p].Name === o) { return n[p] } } return null }; this.getAll = function () { return n }; this.remove = function (p, o) { p = p.toLowerCase(); for (var q = 0; q < n.length; q++) { if (n[q].Name === p) { if (o === undefined) { n.splice(q, 1) } else { n[q].Callbacks.splice(o - 1, 1); if (n[q].Callbacks.length === 0) { n.splice(q, 1) } } return true } } return false }; this.fire = function (q, s, o, p) { q = q.toLowerCase(); for (var r = 0; r < n.length; r++) { if (n[r].Name === q) { if (p === undefined) { n[r].fireCallbacks(s, o) } else { n[r].fireCallback(s, o, p) } } } }; var l = function (o) { this.Name = o; this.Callbacks = []; this.addCallback = function (q, p) { this.Callbacks.push(new m(q, p)) }; this.fireCallback = function (r, p, q) { this.Callbacks[q - 1].fn(r); if (typeof (this.Callbacks[q - 1].state) === "object") { if (typeof (this.Callbacks[q - 1].state.options) !== "undefined" && typeof (this.Callbacks[q - 1].state.options.counter) !== "undefined") { this.Callbacks[q - 1].state.options.counter.messages--; if (this.Callbacks[q - 1].state.options.counter.messages === 0) { if (typeof (this.Callbacks[q - 1].state.options.counter.completed) === "function") { this.Callbacks[q - 1].state.options.counter.completed() } } } } if (p && typeof (p) === "function") { p() } }; this.fireCallbacks = function (q, p) { for (var r = 0; r < this.Callbacks.length; r++) { this.fireCallback(q, p, r + 1) } } }; var m = function (p, o) { this.fn = p; this.state = o }; return this }); this.bind = function (n, l, m, o) { a.add(n, l); if (o && typeof (o) === "function") { o() } }; this.unbind = function (l, m) { a.remove(l); if (m && typeof (m) === "function") { m() } }; this.dispatch = function (l, m, n) { if (a.get(l) === null) { return } if (typeof m === "string") { m = JSON.parse(m) } a.fire(l, m, function () { }) }; var a = new b(); this.channelPublish = function (o, l) { for (var p in j.DataChannels) { var n = j.DataChannels[p]; if (n.readyState === "open") { var m = new XSockets.Message(o, l); n.send(JSON.stringify(m)) } } }; this.closeChannel = function (l) { j.DataChannels[l].close() }; this.channelSubscribe = function (l, m, n) { j.bind(m + l, n) }; this.channelUnsubscribe = function (l, m, n) { j.unbind(m + l, n) }; var c = function (o, m) { var n = this; this.StorageGuid = m; this.RTCPeerConnection = new RTCPeerConnection(o.RTCConfiguration, o.MediaConstraints); this.RTCPeerConnection.onconnection = function () { }; try { j.DataChannels[m] = this.RTCPeerConnection.createDataChannel("RTCDataChannel", { reliable: false }); j.DataChannels[m].onmessage = function (q) { var p = JSON.parse(q.data).JSON; j.dispatch(n.StorageGuid + p.event, p.data, n.StorageGuid) }; j.DataChannels[m].onopen = function () { j.dispatch(XSockets.WebRTC.Events.onDataChannelOpen, { StorageGuid: j.DataChannels[m] }) }; j.DataChannels[m].onclose = function () { j.dispatch(XSockets.WebRTC.Events.onDataChannelClose, { StorageGuid: j.DataChannels[m] }) } } catch (l) { console.log("'Create Data channel failed with exception:", l.message) } this.RTCPeerConnection.onstatechange = function (p) { }; this.RTCPeerConnection.onaddstream = function (p) { j.dispatch(XSockets.WebRTC.Events.onRemoteStream, { StorageGuid: n.StorageGuid, MediaStreamEvent: p }) }; this.RTCPeerConnection.onicecandidate = function (q) { if (q.candidate) { var p = { type: "candidate", label: q.candidate.sdpMLineIndex, id: q.candidate.sdpMid, candidate: q.candidate.candidate }; g.publish("contextsignal", { sender: j.CurrentContext.StorageGuid, recipient: m, message: JSON.stringify(p) }) } }; j.dispatch(XSockets.WebRTC.Events.onPeerConnectionCreated, { StorageGuid: n.StorageGuid }) }; j.bind("connect", function (l) { j.PeerConnections[l.StorageGuid] = new c(k, l.StorageGuid); if (f) { j.PeerConnections[l.StorageGuid].RTCPeerConnection.addStream(f) } j.PeerConnections[l.StorageGuid].RTCPeerConnection.createOffer(function (m) { j.PeerConnections[l.StorageGuid].RTCPeerConnection.setLocalDescription(m); g.publish("contextsignal", { sender: j.CurrentContext.StorageGuid, recipient: l.StorageGuid, message: JSON.stringify(m) }) }, null, k.MediaConstraints) }); j.bind("candidate", function (m) { var l = JSON.parse(m.Message); j.PeerConnections[m.Sender].RTCPeerConnection.addIceCandidate(new RTCIceCandidate({ sdpMLineIndex: l.label, candidate: l.candidate })) }); j.bind("answer", function (l) { j.PeerConnections[l.Sender].RTCPeerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(l.Message))) }); j.bind("offer", function (l) { j.PeerConnections[l.Sender] = new c(k, l.Sender); j.PeerConnections[l.Sender].RTCPeerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(l.Message))); if (f) { j.PeerConnections[l.Sender].RTCPeerConnection.addStream(f) } j.PeerConnections[l.Sender].RTCPeerConnection.createAnswer(function (m) { j.PeerConnections[l.Sender].RTCPeerConnection.setLocalDescription(m); g.publish("contextsignal", { sender: j.CurrentContext.StorageGuid, recipient: l.Sender, message: JSON.stringify(m) }) }, null, k.MediaConstraints) }); g.subscribe("contextcreated", function (l) { j.CurrentContext = new XSockets.PeerContext(l.StorageGuid, l.Context); j.dispatch(XSockets.WebRTC.Events.onContextCreated, l) }); g.subscribe("contextsignal", function (l) { var m = JSON.parse(l.Message); j.dispatch(m.type, l) }); g.subscribe("contextchange", function (l) { j.dispatch(XSockets.WebRTC.Events.onContextChange, l) }); g.subscribe("connectto", function (l) { l.forEach(function (m) { j.dispatch("connect", m) }) }); g.subscribe("peerlost", function (l) { if (j.PeerConnections[l.StorageGuid] !== undefined) { j.PeerConnections[l.StorageGuid].RTCPeerConnection.close(); j.dispatch(XSockets.WebRTC.Events.onPeerConnectionLost, { StorageGuid: l.StorageGuid }) } }); this.ready = function (l, m) { if (l === undefined) { l = "John Doe" } g.publish("initializecontext", { screenName: l }); if (typeof (m) === "object") { m() } }; var h = false; this.muteAudio = function () { var l = f.getAudioTracks(); if (l.length === 0) { console.log("No local audio available."); return } if (h) { for (i = 0; i < l.length; i++) { l[i].enabled = true } } else { for (i = 0; i < l.length; i++) { l[i].enabled = false } } h = !h; console.log(h) }; this.changeContext = function (l) { g.publish("changecontext", { guid: l }) }; this.getUserMedia = function (l, m) { window.getUserMedia(l, function (n) { f = n; j.dispatch(XSockets.WebRTC.Events.onlocalStream, n); if (m && typeof (m) === "function") { m(j.CurrentContext) } }, function (n) { console.log("getUserMediaError", n) }) } }; XSockets.PeerContext = function (a, b) { this.StorageGuid = a; this.Context = b }; XSockets.WebRTC.CallManager = function (a, c) { var b = c.events; this.call = function (d) { a.trigger("OfferContext", { storageGuid: d.StorageGuid }) }; this.setScreenName = function (d) { a.trigger("PeerScreenName", { screenName: d }) }; this.acceptCall = function (d) { b.onAcceptCall(d) }; this.denyCall = function (d) { a.trigger("DenyContext", { storageGuid: d.StorageGuid }) }; this.endCall = function () { a.trigger("LeaveContext", {}) }; a.subscribe("ContextOffer", b.onCall); a.subscribe("ContextDeny", b.onDenyCall) }; Array.prototype.indexOfObject = function (b) { for (var a = 0; a <= this.length; a++) { if (typeof (this[a]) === "object" && JSON.stringify(this[a]) === JSON.stringify(b)) { return a } } if (a > this.length) { return -1 } else { return a } }; XSockets.WebRTC.Events = { onlocalStream: "onLocalStream", onRemoteStream: "onRemoteStream", onContextChange: "onContextChange", onContextCreated: "onContextCreated", onPeerConnectionCreated: "onPeerConnectionCreated", onPeerConnectionLost: "onPeerConnectionLost", onDataChannelOpen: "onDataChannelOpen", onDataChannelClose: "onDataChannelClose" };